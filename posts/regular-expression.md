---
title: "regular-expression"
date: "2021-01-02"
---

### 简介
在编程语言中，正则常常用来简化文本处理的逻辑。在 Linux 命令中，它也可以帮助我们轻松地查找或编辑文件的内容，甚至实现整个文件夹中所有文件的内容替换，比如 grep、egrep、sed、awk、vim 等。另外，在各种文本编辑器中，比如 Atom，Sublime Text 或 VS Code 等，在查找或替换的时候也会使用到它。总之，正则是无处不在的，已经渗透到了日常工作的方方面面。

### 流程
正则表达式解决流程

**第一步,做分解**。拿到一个问题后，我们要先思考：这个问题可以分为几个子问题？每个子问题是否独立？我们拿最常见的电子邮件地址匹配来说。从文本结构来看，它可以分为“username + @ + domain name”这三个独立的部分。怎么画呢？我们可以先画出逻辑结构图。通过这个过程来厘清思路。当然，这是软件⼯程最基本的思路，相信你做起来应该问题不大。

**第二部，分析各个子问题**。某个位置上可能有多个字符？那就用字符组。某个位置上可能有多个字符串？那就用多选结构。出现的次数不确定？那就用量词。对出现的位置有要求？那就用锚点锁定位置…… 某种程度上，这就像武术里的见招拆招，每个问题都有对应的解法，只要熟练掌握了，知道什么时候用字符组，什么时候用多选结构，什么时候用量词，什么时候用锚点，就很容易搭建起完整的概念模型。

**第三部，套皮**。你大概注意到了，到现在，我们还没有谈论正则表达式的典型标志，比如方括号、星号、花括号。要知道，这些典型标志无非只是一些符号而已，真正重要的是字符组、多选结构、量词等等这些概念。一旦你的概念模型清楚了，写出正则表达式就非常简单了，无非是查阅语法手册，把之前得到的概念模型按照对应语言或工具的约定写下来而已。许多人觉得正则表达式难懂，总是纠缠于“这里为什么要多一个星号？那里为什么是方括号而不是花括号？”，原因恰恰在于对概念模型不清楚。虽然各种语言或工具对正则表达式的支持大同小异，但细微差别仍然不可忽视。不过只要你心怀正念，洞若观火，这些差异其实并不是大问题。

**第四步,调试**。很多人都说，正则表达式的麻烦之处在于它像个黑箱子，很难调试，迄今为止仍然没有特别好用的⼯具，所以我们没法⼀步步跟进去看匹配的具体过程，只能笼统地知道“匹配了”或者“没匹配”。

### 书写注意事项

**第⼀，能用普通字符串处理的，坚决⽤普通字符串处理**。字符串处理的速度不见得差，可读性却好上很多。如果要在大段文本中定位所有的 today 或者 tomorrow，用最简单的字符串查找，直接找两遍，明显比 to(day|morrow) 看起来更清楚。

**第⼆，能写注释的正则表达式，⼀定要写注释**。正则表达式的语法非常古老，不够直观，为了便于阅读和维护，如今大部分语言里都可以通过 x 打开注释模式。有了注释，复杂正则表达式的结构也能一目了然。

**第三，能用多个简单正则表达式解决的，⼀定不要苛求用一个复杂的正则表达式**。这里最明显的例子就是输入条件的验证。比如说，常见的密码要求“必须包含数字、小写字母、大写字母、特殊符号中的至少两种，且长度在 8 到 16 之间”。



### 元字符的概念



元字符就是指那些在正则表达式中具有特殊意义的专用字符



![image-20210728220523067](https://tva1.sinaimg.cn/large/008i3skNgy1gsx0kna8t9j30u00vq76o.jpg)



### 贪婪模式

**定义**：表示次数的量词，尽可能最大长度去匹配字符串

```js
let regexp = /a*/g;
let str = 'aaabb';
let array = [...str.matchAll(regexp)];
console.log(array)
```

结果如下:

![image-20210728224622226](https://tva1.sinaimg.cn/large/008i3skNgy1gsx1r8lhb8j30om04k757.jpg)

使用 a* 在 aaabb 这个字符串中进行查找，这次我们看到可以找到 4 个匹配结果

![image-20210728225205119](https://tva1.sinaimg.cn/large/008i3skNgy1gsx1x70sjgj30gy086dg9.jpg)

a* 在匹配开头的 a 时，会尝试尽量匹配更多的 a，直到第一个字母 b 不满足要求为止，匹配上三个 a，后面每次匹配时都得到了空字符串。

regex = “xy{1,3}z”

text = “xyyz”

在匹配时，y{1,3}会尽可能长地去匹配，当匹配完 xyy 后，由于 y 要尽可能匹配最长，即三个，但字符串中后面是个 z 就会导致匹配不上，这时候正则就会向前回溯，吐出当前字符 z，接着用正则中的 z 去匹配。

![image-20210801200251574](https://tva1.sinaimg.cn/large/008i3skNgy1gt1jicfk3xj30hh06zaaa.jpg)





### 非贪婪模式

**定义**："数量"元字符后加?,找出长度最小且满足要求的的字符串， 尽可能短地去匹配字符串

regex = “xy{1,3}?z”

text = “xyyz”

由于 y{1,3}? 代表匹配 1 到 3 个 y，尽可能少地匹配。匹配上一个 y 之后，也就是在匹配上 text 中的 xy 后，正则会使用 z 和 text 中的 xy 后面的 y 比较，发现正则 z 和 y 不匹配，这时正则就会向前回溯，重新查看 y 匹配两个的情况，匹配上正则中的 xyy，然后再用 z 去匹配 text 中的 z，匹配成功。

![image-20210801200140585](https://tva1.sinaimg.cn/large/008i3skNgy1gt1jh4ead2j30g806jjro.jpg)



### 独占模式

不管是贪婪模式，还是非贪婪模式，都需要发生回溯才能完成相应的功能，但是在一些场景下，我们不需要回溯，匹配不上返回失败就好了，独占模式类似贪婪匹配，但匹配过程不会发生回溯。具体方法在量词后面加上加号(+)

```python
re.findall('xy{1,3}+yz','xyyz')
```

不过在python中会报错(目前python和go标准库并不支持独占模式) 加号会被程序认为是重复次数的元字符

![image-20210801145354310](https://tva1.sinaimg.cn/large/008i3skNgy1gt1akx83trj30u009ijsw.jpg)

可以安装regex模块

```python

>>> import regex
>>> regex.findall(r'xy{1,3}z', 'xyyz')  # 贪婪模式
['xyyz']
>>> regex.findall(r'xy{1,3}+z', 'xyyz') # 独占模式
['xyyz']
>>> regex.findall(r'xy{1,2}+yz', 'xyyz') # 独占模式
[]
```



|            | 正则      | 文本 | 结果   |
| ---------- | --------- | ---- | ------ |
| 贪婪模式   | x{1,3}xy  | xxxy | 匹配   |
| 非贪婪模式 | x{1,3}?xy | xxxy | 匹配   |
| 独占模式   | x{1,3}+xy | xxxy | 不匹配 |

如果用x{1,3}+xy去匹配xxxy字符串，x{1,3}会把前面三个x都用掉,那文本中只剩下一个y，正则+后面的x无法匹配，导致匹配失败。



**造成回溯的条件**

* 多分枝结构
* 量词

### 分组与引用

分组用括号括起

* 可以表示一个整体
* 复用



#### 分组与编号

括号在正则中可以用于分组，被括号括起来的部分”子表达式“会被保存成一个子组。

![image-20210801220251264](https://tva1.sinaimg.cn/large/008i3skNgy1gt1mz7ebksj30h605jq2z.jpg)

如果括号嵌套的话，只需要数左括号是第几个，就可以确定是第几个子组

![image-20210801220645844](https://tva1.sinaimg.cn/large/008i3skNgy1gt1n39gosfj30g503owej.jpg)

不保存子组可以提高正则性能 在括号里面加?:

保存子组后续可以继续使用



#### 命名分组

前面我们讲了分组编号，但由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还可能导致编号发生变化，因此一些编程语言提供了命名分组（named grouping），这样和数字相比更容易辨识，不容易出错。命名分组的格式为(?P<分组名>正则)

![image-20210824220037533](https://tva1.sinaimg.cn/large/008i3skNgy1gts860m0xwj60x40c03zq02.jpg)

```js
the little cat cat is in the hat hat hat, we like it.

查找匹配
/(\b\w+\b)(?:\s+\1)+/gm
  
替换匹配
/1

```



#### 匹配模式

### 匹配模式

概念: 正则中一些改变元字符匹配行为的方式

#### 不区分大小写模式

![image-20210824230903544](https://tva1.sinaimg.cn/large/008i3skNgy1gtsa56ct57j60ex05nq2y02.jpg)



1. 不区分大小写模式的指定方式，使用模式修饰符(?i);
2. 修饰符如果在括号内，作用范围是这个括号内的正则，而不是整个正则
3. 使用编程语言时可以使用预定义好的常量来指定匹配模式
4. 在js中需要使用/regex/i来指定匹配模式。

#### 点号通配模式

让英文的点可以匹配上包括换行的任何字符

![image-20210824234533681](https://tva1.sinaimg.cn/large/008i3skNgy1gtsb75mjxaj60ra04p0sy02.jpg)

在js中不支持这种语法，可以用[\s\S]+代替

![image-20210824234748287](https://tva1.sinaimg.cn/large/008i3skNgy1gtsb9hlpfrj60r904j0sv02.jpg)

#### 多行匹配模式

概念：^匹配整个字符串的开头，$ 匹配整个字符串的结尾。多行匹配模式改变的就是 ^ 和 $ 的匹配行为

![image-20210824235301168](https://tva1.sinaimg.cn/large/008i3skNgy1gtsbewqh6wj60r70443yk02.jpg)

多行模式的作用在于，使 ^ 和 $ 能匹配上每行的开头或结尾，我们可以使用模式修饰符号 (?m) 来指定这个模式。

![image-20210824235354546](https://tva1.sinaimg.cn/large/008i3skNgy1gtsbfuf0qhj60r903vq3202.jpg)

#### 注释模式

在实际工作中，正则可能会很复杂，这就导致编写、阅读和维护正则都会很困难。我们在写代码的时候，通常会在一些关键的地方加上注释，让代码更易于理解。很多语言也支持在正则中添加注释，让正则更容易阅读和维护，这就是正则的注释模式。正则中注释模式是使用 (?#comment) 来表示

![image-20210825000315718](https://tva1.sinaimg.cn/large/008i3skNgy1gtsbpks8apj60qy06n3ys02.jpg)

```js
var template = 'cat cat CAt cAt caT CAT Dog Dog ABC ABC'
var regex = /((?i)(\w+))(?#word) \1(?#word repeat again)/gm
```



### 断言

什么是断言呢？简单来说，断言是指对匹配到的文本位置有要求。这么说你可能还是没理解，我通过一些例子来给你讲解。你应该知道 \d{11} 能匹配上 11 位数字，但这 11 位数字可能是 18 位身份证号中的一部分。再比如，去查找一个单词，我们要查找 tom，但其它的单词，比如 tomorrow 中也包含了 tom。也就是说，在有些情况下，我们对要匹配的文本的位置也有一定的要求。为了解决这个问题，正则中提供了一些结构，只用于匹配位置，而不是文本内容本身，这种结构就是断言。常见的断言有三种：单词边界、行的开始或结束以及环视

#### 单词边界

```js
var template = 'tom asked me if I would go fishing with him tomorrow.'
//匹配tom这个单词
var regex = /\btom\b/
```

单词的组成一般可以用元字符 \w+ 来表示，\w 包括了大小写字母、下划线和数字（即 [A-Za-z0-9_]）。那如果我们能找出单词的边界，也就是当出现了\w 表示的范围以外的字符，比如引号、空格、标点、换行等这些符号，我们就可以在正则中使用\b 来表示单词的边界。 \b 中的 b 可以理解为是边界（Boundary）这个单词的首字母。



#### 行的开始/结束

如果我们要求匹配的内容要出现在一行文本开头或结尾，就可以使用 ^ 和 $ 来进行位置界定



应用: 

**日志起始行的判断** 

最常见的例子就是日志收集，我们在收集日志的时候，通常可以指定日志行的开始规则，比如以时间开头，那些不是以时间开头的可能就是打印的堆栈信息，我们就通过日期时间开头来判断哪一行是日志的第一行，在日期时间后面的日志都属于同一条日志。除非我们看见下一个日期时间的出现，才是下一条日志的开始

 **输入数据校验**

在 Web 服务中，我们常常需要对输入的内容进行校验，比如要求输入 6 位数字，我们可以使用 \d{6} 来校验。但你需要注意到，如果用户输入的是 6 位以上的数字呢？在这种情况下，如果不去要求用户录入的 6 位数字必须是行的开头或结尾，就算验证通过了，结果也可能不对。比如下面的示例，在不加行开始和结束符号时，用户输入了 7 位数字，也是能校验通过的：

```js
var template = '123456';
var regex = /^\d{6}$/;
console.log(template.match(regex));
```



#### 环视

环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则，有些地方也称环视为零宽断言

![image-20210825004817931](https://tva1.sinaimg.cn/large/008i3skNgy1gtsd0fuygkj62700u0ag202.jpg)



### 转义

​	在计算机科学与远程通信中，当转义字符放在字符序列中，它将对它后续的几个字符进行替代并解释。通常，判定某字符是否为转义字符由上下文确定。转义字符即标志着转义序列开始的那个字符。



#### 字符串转义

字符串转义：输入字符串到字符串文本的过程

#### 正则转义

正则文字到正则表达式的过程

```shell
const str = '\\n\n\\'
const sources = ['\n', '\\n', '\\\n', '\\\\n']
const regs = []

sources.forEach(s => regs.push(new RegExp(s, 'g')))
regs.forEach(reg => {
  console.log('[current reg] ', reg)
  let once_match = reg.exec(str)
  console.log('[result]', once_match)
})
```



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtuna2hkc5j60eo03uaak02.jpg" alt="image-20210827001438104"  />



![image-20210827001634487](https://tva1.sinaimg.cn/large/008i3skNgy1gtunc1jkkrj6130096glv02.jpg)

### 正则有哪些常见的流派及其特性





### 正则处理Unicode

​	

#### Unicode基础知识

Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字进行了整理、编码。Unicode 使计算机呈现和处理文字变得简单。



Unicode 至今仍在不断增修，每个新版本都加入更多新的字符。目前 Unicode 最新的版本为 2020 年 3 月 10 日公布的 13.0.0，已经收录超过 14 万个字符。



现在的 Unicode 字符分为 17 组编排，每组为一个平面（Plane），而每个平面拥有 65536（即 2 的 16 次方）个码值（Code Point）。然而，目前 Unicode 只用了少数平面，我们用到的绝大多数字符都属于第 0 号平面，即 BMP 平面。除了 BMP 平面之外，其它的平面都被称为补充平面。





### 如何在编辑器中使用正则完成工作



#### 多焦点编辑



#### 竖向编辑





### 如何在语言中用正则让文本处理能力上一个台阶



### 如何理解正则的匹配原理以及优化原则



### 详解正则常见问题及解决方案



### 从编程语言的角度来理解正则表达式











### 练习题

有一篇英文文章，里面有很多单词，单词和单词之间是用空格隔开的，在引号里面的一到多个单词表示特殊含义，即引号里面的多个单词要看成一个单词。现在你需要提取出文章中所有的单词。我们可以假设文章中除了引号没有其它的标点符号，有什么方法可以解决这个问题呢？如果用正则来解决，你能不能写出一个正则，提取出文章中所有的单词呢（不要求结果去重）？

we found “the little cat” is in the hat, we like “the little cat”

其中 the little cat 需要看成一个单词



```js
let regex1 = /\w+|“[^“]*”/  //贪婪匹配
let regex2 = /\w+|“.+?”/  //非贪婪匹配
let regex3 = /\w+|“[\w\s]+?”/    //非贪婪匹配


```









### 正则网站or软件

1.  https://regex101.com/ 
2.  https://tool.oschina.net/regex/
3.  http://tool.chinaz.com/regex/
4.  https://www.w3cschool.cn/tools/index?name=re
5.  https://c.runoob.com/front-end/854
6.  http://tools.haokh.net/Regex
7.  Windows 上推荐：RegexBuddy
8.  Mac上推荐：Expressions
