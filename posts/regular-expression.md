---
title: "regular-expression"
date: "2021-01-02"
---

### 简介
在编程语言中，正则常常用来简化文本处理的逻辑。在 Linux 命令中，它也可以帮助我们轻松地查找或编辑文件的内容，甚至实现整个文件夹中所有文件的内容替换，比如 grep、egrep、sed、awk、vim 等。另外，在各种文本编辑器中，比如 Atom，Sublime Text 或 VS Code 等，在查找或替换的时候也会使用到它。总之，正则是无处不在的，已经渗透到了日常工作的方方面面。

### 流程
正则表达式解决流程

**第一步,做分解**。拿到一个问题后，我们要先思考：这个问题可以分为几个子问题？每个子问题是否独立？我们拿最常见的电子邮件地址匹配来说。从文本结构来看，它可以分为“username + @ + domain name”这三个独立的部分。怎么画呢？我们可以先画出逻辑结构图。通过这个过程来厘清思路。当然，这是软件⼯程最基本的思路，相信你做起来应该问题不大。

**第二部，分析各个子问题**。某个位置上可能有多个字符？那就用字符组。某个位置上可能有多个字符串？那就用多选结构。出现的次数不确定？那就用量词。对出现的位置有要求？那就用锚点锁定位置…… 某种程度上，这就像武术里的见招拆招，每个问题都有对应的解法，只要熟练掌握了，知道什么时候用字符组，什么时候用多选结构，什么时候用量词，什么时候用锚点，就很容易搭建起完整的概念模型。

**第三部，套皮**。你大概注意到了，到现在，我们还没有谈论正则表达式的典型标志，比如方括号、星号、花括号。要知道，这些典型标志无非只是一些符号而已，真正重要的是字符组、多选结构、量词等等这些概念。一旦你的概念模型清楚了，写出正则表达式就非常简单了，无非是查阅语法手册，把之前得到的概念模型按照对应语言或工具的约定写下来而已。许多人觉得正则表达式难懂，总是纠缠于“这里为什么要多一个星号？那里为什么是方括号而不是花括号？”，原因恰恰在于对概念模型不清楚。虽然各种语言或工具对正则表达式的支持大同小异，但细微差别仍然不可忽视。不过只要你心怀正念，洞若观火，这些差异其实并不是大问题。

**第四步,调试**。很多人都说，正则表达式的麻烦之处在于它像个黑箱子，很难调试，迄今为止仍然没有特别好用的⼯具，所以我们没法⼀步步跟进去看匹配的具体过程，只能笼统地知道“匹配了”或者“没匹配”。

### 书写注意事项

**第⼀，能用普通字符串处理的，坚决⽤普通字符串处理**。字符串处理的速度不见得差，可读性却好上很多。如果要在大段文本中定位所有的 today 或者 tomorrow，用最简单的字符串查找，直接找两遍，明显比 to(day|morrow) 看起来更清楚。

**第⼆，能写注释的正则表达式，⼀定要写注释**。正则表达式的语法非常古老，不够直观，为了便于阅读和维护，如今大部分语言里都可以通过 x 打开注释模式。有了注释，复杂正则表达式的结构也能一目了然。

**第三，能用多个简单正则表达式解决的，⼀定不要苛求用一个复杂的正则表达式**。这里最明显的例子就是输入条件的验证。比如说，常见的密码要求“必须包含数字、小写字母、大写字母、特殊符号中的至少两种，且长度在 8 到 16 之间”。



### 元字符的概念



元字符就是指那些在正则表达式中具有特殊意义的专用字符



![image-20210728220523067](https://tva1.sinaimg.cn/large/008i3skNgy1gsx0kna8t9j30u00vq76o.jpg)



### 贪婪模式

**定义**：表示次数的量词，尽可能最大长度去匹配字符串

```js
let regexp = /a*/g;
let str = 'aaabb';
let array = [...str.matchAll(regexp)];
console.log(array)
```

结果如下:

![image-20210728224622226](https://tva1.sinaimg.cn/large/008i3skNgy1gsx1r8lhb8j30om04k757.jpg)

使用 a* 在 aaabb 这个字符串中进行查找，这次我们看到可以找到 4 个匹配结果

![image-20210728225205119](https://tva1.sinaimg.cn/large/008i3skNgy1gsx1x70sjgj30gy086dg9.jpg)

a* 在匹配开头的 a 时，会尝试尽量匹配更多的 a，直到第一个字母 b 不满足要求为止，匹配上三个 a，后面每次匹配时都得到了空字符串。

regex = “xy{1,3}z”

text = “xyyz”

在匹配时，y{1,3}会尽可能长地去匹配，当匹配完 xyy 后，由于 y 要尽可能匹配最长，即三个，但字符串中后面是个 z 就会导致匹配不上，这时候正则就会向前回溯，吐出当前字符 z，接着用正则中的 z 去匹配。

![image-20210801200251574](https://tva1.sinaimg.cn/large/008i3skNgy1gt1jicfk3xj30hh06zaaa.jpg)





### 非贪婪模式

**定义**："数量"元字符后加?,找出长度最小且满足要求的的字符串， 尽可能短地去匹配字符串

regex = “xy{1,3}?z”

text = “xyyz”

由于 y{1,3}? 代表匹配 1 到 3 个 y，尽可能少地匹配。匹配上一个 y 之后，也就是在匹配上 text 中的 xy 后，正则会使用 z 和 text 中的 xy 后面的 y 比较，发现正则 z 和 y 不匹配，这时正则就会向前回溯，重新查看 y 匹配两个的情况，匹配上正则中的 xyy，然后再用 z 去匹配 text 中的 z，匹配成功。

![image-20210801200140585](https://tva1.sinaimg.cn/large/008i3skNgy1gt1jh4ead2j30g806jjro.jpg)



### 独占模式

不管是贪婪模式，还是非贪婪模式，都需要发生回溯才能完成相应的功能，但是在一些场景下，我们不需要回溯，匹配不上返回失败就好了，独占模式类似贪婪匹配，但匹配过程不会发生回溯。具体方法在量词后面加上加号(+)

```python
re.findall('xy{1,3}+yz','xyyz')
```

不过在python中会报错(目前python和go标准库并不支持独占模式) 加号会被程序认为是重复次数的元字符

![image-20210801145354310](https://tva1.sinaimg.cn/large/008i3skNgy1gt1akx83trj30u009ijsw.jpg)

可以安装regex模块

```python

>>> import regex
>>> regex.findall(r'xy{1,3}z', 'xyyz')  # 贪婪模式
['xyyz']
>>> regex.findall(r'xy{1,3}+z', 'xyyz') # 独占模式
['xyyz']
>>> regex.findall(r'xy{1,2}+yz', 'xyyz') # 独占模式
[]
```



|            | 正则      | 文本 | 结果   |
| ---------- | --------- | ---- | ------ |
| 贪婪模式   | x{1,3}xy  | xxxy | 匹配   |
| 非贪婪模式 | x{1,3}?xy | xxxy | 匹配   |
| 独占模式   | x{1,3}+xy | xxxy | 不匹配 |

如果用x{1,3}+xy去匹配xxxy字符串，x{1,3}会把前面三个x都用掉,那文本中只剩下一个y，正则+后面的x无法匹配，导致匹配失败。



### 分组与引用

分组用括号括起

* 可以表示一个整体
* 复用



#### 分组与编号

括号在正则中可以用于分组，被括号括起来的部分”子表达式“会被保存成一个子组。

![image-20210801220251264](https://tva1.sinaimg.cn/large/008i3skNgy1gt1mz7ebksj30h605jq2z.jpg)

如果括号嵌套的话，只需要数左括号是第几个，就可以确定是第几个子组

![image-20210801220645844](https://tva1.sinaimg.cn/large/008i3skNgy1gt1n39gosfj30g503owej.jpg)



#### 命名分组













造成回溯的条件

* 多分枝结构
* 量词









### 练习题

有一篇英文文章，里面有很多单词，单词和单词之间是用空格隔开的，在引号里面的一到多个单词表示特殊含义，即引号里面的多个单词要看成一个单词。现在你需要提取出文章中所有的单词。我们可以假设文章中除了引号没有其它的标点符号，有什么方法可以解决这个问题呢？如果用正则来解决，你能不能写出一个正则，提取出文章中所有的单词呢（不要求结果去重）？

we found “the little cat” is in the hat, we like “the little cat”

其中 the little cat 需要看成一个单词



```js
let regex1 = /\w+|“[^“]*”/  //贪婪匹配
let regex2 = /\w+|“.+?”/  //非贪婪匹配
let regex3 = /\w+|“[\w\s]+?”/    //非贪婪匹配


```









### 正则网站or软件

1.  https://regex101.com/ 
2.  https://tool.oschina.net/regex/
3.  http://tool.chinaz.com/regex/
4.  https://www.w3cschool.cn/tools/index?name=re
5.  https://c.runoob.com/front-end/854
6.  http://tools.haokh.net/Regex
7.  Windows 上推荐：RegexBuddy
8.  Mac上推荐：Expressions
